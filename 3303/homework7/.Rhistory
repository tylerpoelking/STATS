# run algorithm to get interations for inference
codaSamples <- coda.samples( jagsModel,
variable.names = parameters,
n.iter = ITER,
thin = thinSteps )
# -------------
# Look at posterior samples
# -------------
# make a dataframe with the posterior samples
mcmcChainDF <- data.frame( as.matrix( codaSamples,
iters = T,
chains = T ) )
# create a vector with the variable names
varNames <- names( mcmcChainDF )[3:( dim( mcmcChainDF )[2] )]
# number of variables
nVars <- length( varNames )
mcmcChainDF$CHAIN <- as.factor(mcmcChainDF$CHAIN)
# construct trace plots
p <- list()
for( k in 1:nVars )
{
plot_frame <- mcmcChainDF
plot_frame$dep_var <- mcmcChainDF[ , varNames[k]]
p[[k]] <- ggplot( plot_frame,
aes( x = ITER,
y = dep_var))  +
geom_line( aes( color = CHAIN ) ) +
labs( y = varNames[k] )
}
postDFreshape <- melt( mcmcChainDF,
id.vars = "ITER",
measure.vars = c("theta.1.",
"theta.2.",
"theta.3.",
"theta.4.",
"theta.5.",
"theta.6.",
"theta.7.",
"theta.8.",
"mu"))
do.call( grid.arrange, c( p, list("ncol" = 1) ) )
# burn-in the algorithm
update( jagsModel,
n.iter = burnInSteps )
# run algorithm to get interations for inference
codaSamples <- coda.samples( jagsModel,
variable.names = parameters,
n.iter = ITER,
thin = thinSteps )
# -------------
# Look at posterior samples
# -------------
# make a dataframe with the posterior samples
mcmcChainDF <- data.frame( as.matrix( codaSamples,
iters = T,
chains = T ) )
# create a vector with the variable names
varNames <- names( mcmcChainDF )[3:( dim( mcmcChainDF )[2] )]
# number of variables
nVars <- length( varNames )
mcmcChainDF$CHAIN <- as.factor(mcmcChainDF$CHAIN)
# construct trace plots
p <- list()
par(ask = T)
for( k in 1:nVars )
{
plot_frame <- mcmcChainDF
plot_frame$dep_var <- mcmcChainDF[ , varNames[k]]
p[[k]] <- ggplot( plot_frame,
aes( x = ITER,
y = dep_var))  +
geom_line( aes( color = CHAIN ) ) +
labs( y = varNames[k] )
}
do.call( grid.arrange, c( p, list("ncol" = 1) ) )
knitr::opts_chunk$set(echo = TRUE)
set.seed(23422432)
library(rjags)
library(ggplot2)
library(grid)
library(gridExtra)
library(reshape2)
# read in the data and calculate some
# summaries
schoolData <- read.table( "~/Desktop/All Stuff/School Stuff/STATS/3303/homework7/friends.txt", header=T )
y <- schoolData$y
x <- schoolData$x
school <- schoolData$school
pair <- schoolData$pair
schoolNames <- unique(school)
schoolsNumeric <- as.numeric(schoolNames)
nSchools = length(schoolNames)
nPairs <- length(schoolData)
# create objects for JAGS
dataList <- list( "y" = y,
"x" = x,
'pair' = pair,
'school' = school,
"nPairs" = nPairs,
"nSchools" = nSchools)
# list of parameters to be monitored
parameters <- c( 'alpha',"beta", "mu.beta",
"mu.alpha",
"sigma2.beta",
"sigma2.alpha")
# set initial values
initsValues <- list('alpha' = rep(1, nSchools),
'beta' = rep(1,nSchools),
"mu.beta" = 1,
"mu.alpha" = 1,
"sigma2.beta" = 5,
"sigma2.alpha" = 5)
# number of iteration for "tuning"
adaptSteps <- 5000
# number of iterations for "burn-in"
burnInSteps <- 5000
# number of chains to run
nChains <- 2
# total number of iterations to save
numSavedSteps <- 5000
# "thinning" (1 = keep every interation)
thinSteps <- 1
# iterations per chain
ITER <- ceiling( (numSavedSteps * thinSteps) / nChains )
# -------------
# Run JAGS
# -------------
# create, initialize, and adapt the model
jagsModel <- jags.model( "~/Desktop/All Stuff/School Stuff/STATS/3303/homework7/model.txt",
data = dataList,
inits = initsValues,
n.chains = nChains,
n.adapt = adaptSteps )
# burn-in the algorithm
update( jagsModel,
n.iter = burnInSteps )
# run algorithm to get interations for inference
codaSamples <- coda.samples( jagsModel,
variable.names = parameters,
n.iter = ITER,
thin = thinSteps )
# -------------
# Look at posterior samples
# -------------
# make a dataframe with the posterior samples
mcmcChainDF <- data.frame( as.matrix( codaSamples,
iters = T,
chains = T ) )
# create a vector with the variable names
varNames <- names( mcmcChainDF )[3:( dim( mcmcChainDF )[2] )]
# number of variables
nVars <- 20
mcmcChainDF$CHAIN <- as.factor(mcmcChainDF$CHAIN)
# construct trace plots
p <- list()
par(ask = T)
for( k in 1:nVars )
{
plot_frame <- mcmcChainDF
plot_frame$dep_var <- mcmcChainDF[ , varNames[k]]
p[[k]] <- ggplot( plot_frame,
aes( x = ITER,
y = dep_var))  +
geom_line( aes( color = CHAIN ) ) +
labs( y = varNames[k] )
}
do.call( grid.arrange, c( p, list("ncol" = 1)))
knitr::opts_chunk$set(echo = TRUE)
set.seed(23422432)
library(rjags)
library(ggplot2)
library(grid)
library(gridExtra)
library(reshape2)
# read in the data and calculate some
# summaries
schoolData <- read.table( "~/Desktop/All Stuff/School Stuff/STATS/3303/homework7/friends.txt", header=T )
y <- schoolData$y
x <- schoolData$x
school <- schoolData$school
pair <- schoolData$pair
schoolNames <- unique(school)
schoolsNumeric <- as.numeric(schoolNames)
nSchools = length(schoolNames)
nPairs <- length(schoolData)
# create objects for JAGS
dataList <- list( "y" = y,
"x" = x,
'pair' = pair,
'school' = school,
"nPairs" = nPairs,
"nSchools" = nSchools)
# list of parameters to be monitored
parameters <- c( 'alpha',"beta", "mu.beta",
"mu.alpha",
"sigma2.beta",
"sigma2.alpha")
# set initial values
initsValues <- list('alpha' = rep(1, nSchools),
'beta' = rep(1,nSchools),
"mu.beta" = 1,
"mu.alpha" = 1,
"sigma2.beta" = 5,
"sigma2.alpha" = 5)
# number of iteration for "tuning"
adaptSteps <- 5000
# number of iterations for "burn-in"
burnInSteps <- 5000
# number of chains to run
nChains <- 2
# total number of iterations to save
numSavedSteps <- 5000
# "thinning" (1 = keep every interation)
thinSteps <- 1
# iterations per chain
ITER <- ceiling( (numSavedSteps * thinSteps) / nChains )
# -------------
# Run JAGS
# -------------
# create, initialize, and adapt the model
jagsModel <- jags.model( "~/Desktop/All Stuff/School Stuff/STATS/3303/homework7/model.txt",
data = dataList,
inits = initsValues,
n.chains = nChains,
n.adapt = adaptSteps )
# burn-in the algorithm
update( jagsModel,
n.iter = burnInSteps )
# run algorithm to get interations for inference
codaSamples <- coda.samples( jagsModel,
variable.names = parameters,
n.iter = ITER,
thin = thinSteps)
# -------------
# Look at posterior samples
# -------------
# make a dataframe with the posterior samples
mcmcChainDF <- data.frame( as.matrix( codaSamples,
iters = T,
chains = T ) )
# create a vector with the variable names
varNames <- names( mcmcChainDF )[3:( dim( mcmcChainDF )[2] )]
# number of variables
nVars <- 20
mcmcChainDF$CHAIN <- as.factor(mcmcChainDF$CHAIN)
# construct trace plots
p <- list()
par(ask = T)
for( k in 1:nVars )
{
plot_frame <- mcmcChainDF
plot_frame$dep_var <- mcmcChainDF[ , varNames[k]]
p[[k]] <- ggplot( plot_frame,
aes( x = ITER,
y = dep_var))  +
geom_line( aes( color = CHAIN ) ) +
labs( y = varNames[k] )
}
do.call( grid.arrange, c( p, list("ncol" = 1)))
nVars
postDFreshape <- melt( mcmcChainDF,
id.vars = "ITER",
measure.vars = c("alpha.1.",
"alpha.2",
"alpha.3.",
"alpha.4",
"alpha.5.",
"alpha.6.",
"alpha.7.",
"alpha.8.",
"mu.alpha"))
varNames
postDFreshape <- melt( mcmcChainDF,
id.vars = "ITER",
measure.vars = c("alpha.1.",
"alpha.2.",
"alpha.3.",
"alpha.4.",
"alpha.5.",
"alpha.6.",
"alpha.7.",
"alpha.8.",
"mu.alpha"))
ggplot(postDFreshape,
aes(x = variable, y = value )) +
geom_boxplot() +
scale_x_discrete( labels = c( deptNames, "mu" )) +
ylab( "posterior" ) +
xlab( "alpha" )
postDFreshape <- melt( mcmcChainDF,
id.vars = "ITER",
measure.vars = c("alpha.1.",
"alpha.2.",
"alpha.3.",
"alpha.4.",
"alpha.5.",
"alpha.6.",
"alpha.7.",
"alpha.8.",
"mu.alpha"))
ggplot(postDFreshape,
aes(x = variable, y = value )) +
geom_boxplot() +
scale_x_discrete( labels = c( schoolNames, "mu" )) +
ylab( "posterior" ) +
xlab( "alpha" )
postDFreshape <- melt( mcmcChainDF,
id.vars = "ITER",
measure.vars = c("beta.1.",
"beta.2.",
"beta.3.",
"beta.4.",
"beta.5.",
"beta.6.",
"beta.7.",
"beta.8.",
"mu.beta"))
ggplot(postDFreshape,
aes(x = variable, y = value )) +
geom_boxplot() +
scale_x_discrete( labels = c( schoolNames, "mu" )) +
ylab( "posterior" ) +
xlab( "beta" )
# burn-in the algorithm
update( jagsModel,
n.iter = burnInSteps )
# run algorithm to get interations for inference
codaSamples <- coda.samples( jagsModel,
variable.names = parameters,
n.iter = ITER,
thin = thinSteps)
# -------------
# Look at posterior samples
# -------------
# make a dataframe with the posterior samples
mcmcChainDF <- data.frame( as.matrix( codaSamples,
iters = T,
chains = T ) )
# create a vector with the variable names
varNames <- names( mcmcChainDF )[3:( dim( mcmcChainDF )[2] )]
# number of variables
nVars <- 20
mcmcChainDF$CHAIN <- as.factor(mcmcChainDF$CHAIN)
# construct trace plots
p <- list()
par(ask = T)
for( k in 1:nVars )
{
plot_frame <- mcmcChainDF
plot_frame$dep_var <- mcmcChainDF[ , varNames[k]]
p[[k]] <- ggplot( plot_frame,
aes( x = ITER,
y = dep_var))  +
geom_line( aes( color = CHAIN ) ) +
labs( y = varNames[k] )
}
#do.call( grid.arrange, c( p, list("ncol" = 1)))
mcmcChainDF$mu.alpha
logit(mcmcChainDF$mu.alpha)
library(math)
install.packages('math')
install.packages('manip')
library(aod)
install.packages('aod')
library(aod)
inv.logit(1)
install.packages('boot')
library(boot)
inv.logit(1)
prob_alpha.post <- inv.logit(alpha.post)
alpha.post <- mcmcChainDF$mu.alpha
prob_alpha.post <- inv.logit(alpha.post)
prob_alpha.post
mean(prob_alpha.post)
mean(prob_alpha.post + prob_beta.post)
beta.post <- mcmcChainDF$mu.beta
prob_beta.post <- inv.logit(beta.post)
mean(prob_alpha.post + prob_beta.post)
beta.post <- mcmcChainDF$mu.beta
x = alpha.post + beta.post
prob_beta.post <- inv.logit(x)
mean(x)
x
prob_x.post <- inv.logit(x)
mean(prob_x.post)
# burn-in the algorithm
update( jagsModel,
n.iter = burnInSteps )
# run algorithm to get interations for inference
codaSamples <- coda.samples( jagsModel,
variable.names = parameters,
n.iter = ITER,
thin = thinSteps)
# -------------
# Look at posterior samples
# -------------
# make a dataframe with the posterior samples
mcmcChainDF <- data.frame( as.matrix( codaSamples,
iters = T,
chains = T ) )
# create a vector with the variable names
varNames <- names( mcmcChainDF )[3:( dim( mcmcChainDF )[2] )]
# number of variables
nVars <- 20
mcmcChainDF$CHAIN <- as.factor(mcmcChainDF$CHAIN)
# construct trace plots
p <- list()
par(ask = T)
for( k in 1:nVars )
{
plot_frame <- mcmcChainDF
plot_frame$dep_var <- mcmcChainDF[ , varNames[k]]
p[[k]] <- ggplot( plot_frame,
aes( x = ITER,
y = dep_var))  +
geom_line( aes( color = CHAIN ) ) +
labs( y = varNames[k] )
}
do.call( grid.arrange, c( p, list("ncol" = 1)))
knitr::opts_chunk$set(echo = TRUE)
set.seed(23422432)
library(rjags)
library(boot)
library(ggplot2)
library(grid)
library(gridExtra)
library(reshape2)
# read in the data and calculate some
# summaries
schoolData <- read.table( "~/Desktop/All Stuff/School Stuff/STATS/3303/homework7/friends.txt", header=T )
y <- schoolData$y
x <- schoolData$x
school <- schoolData$school
pair <- schoolData$pair
schoolNames <- unique(school)
schoolsNumeric <- as.numeric(schoolNames)
nSchools = length(schoolNames)
nPairs <- length(schoolData)
# create objects for JAGS
dataList <- list( "y" = y,
"x" = x,
'pair' = pair,
'school' = school,
"nPairs" = nPairs,
"nSchools" = nSchools)
# list of parameters to be monitored
parameters <- c( 'alpha',"beta", "mu.beta",
"mu.alpha",
"sigma2.beta",
"sigma2.alpha")
# set initial values
initsValues <- list('alpha' = rep(1, nSchools),
'beta' = rep(1,nSchools),
"mu.beta" = 1,
"mu.alpha" = 1,
"sigma2.beta" = 5,
"sigma2.alpha" = 5)
# number of iteration for "tuning"
adaptSteps <- 5000
# number of iterations for "burn-in"
burnInSteps <- 5000
# number of chains to run
nChains <- 2
# total number of iterations to save
numSavedSteps <- 5000
# "thinning" (1 = keep every interation)
thinSteps <- 1
# iterations per chain
ITER <- ceiling( (numSavedSteps * thinSteps) / nChains )
# -------------
# Run JAGS
# -------------
# create, initialize, and adapt the model
jagsModel <- jags.model( "~/Desktop/All Stuff/School Stuff/STATS/3303/homework7/model.txt",
data = dataList,
inits = initsValues,
n.chains = nChains,
n.adapt = adaptSteps )
# burn-in the algorithm
update( jagsModel,
n.iter = burnInSteps )
# run algorithm to get interations for inference
codaSamples <- coda.samples( jagsModel,
variable.names = parameters,
n.iter = ITER,
thin = thinSteps)
# -------------
# Look at posterior samples
# -------------
# make a dataframe with the posterior samples
mcmcChainDF <- data.frame( as.matrix( codaSamples,
iters = T,
chains = T ) )
# create a vector with the variable names
varNames <- names( mcmcChainDF )[3:( dim( mcmcChainDF )[2] )]
# number of variables
nVars <- 20
mcmcChainDF$CHAIN <- as.factor(mcmcChainDF$CHAIN)
# construct trace plots
p <- list()
par(ask = T)
for( k in 1:nVars )
{
plot_frame <- mcmcChainDF
plot_frame$dep_var <- mcmcChainDF[ , varNames[k]]
p[[k]] <- ggplot( plot_frame,
aes( x = ITER,
y = dep_var))  +
geom_line( aes( color = CHAIN ) ) +
labs( y = varNames[k] )
}
do.call( grid.arrange, c( p, list("ncol" = 3)))
