geom_boxplot( fill = c(rep(cols[3], deptsUniqCount),
cols[1]),
color = "darkgrey") +
ylab( "posterior" ) +
xlab( "theta" ) +
scale_x_discrete( labels = c("BM","CH", "CS", "CV", "EE", "IN", "MC", "MS", "mu" )) +
theme(axis.title.x = element_text(colour = cols[3]) )
+ ggtitle('test')
postDFreshape <- melt( mcmcChainDF, id.vars = "ITER", measure.vars = c("theta.1.", "theta.2.", "theta.3.", "theta.4.", "theta.5.", "theta.6.", "theta.7.", "theta.8.", "mu"))
plot = ggplot(postDFreshape,
aes(x = variable, y = value )) +
geom_boxplot( fill = c(rep(cols[3], deptsUniqCount),
cols[1]),
color = "darkgrey") +
+ labs(title="Posterior Distributions",
x ="theta", y = "posterior") +
#ylab( "posterior" ) +
# xlab( "theta" ) +
scale_x_discrete( labels = c("BM","CH", "CS", "CV", "EE", "IN", "MC", "MS", "mu" )) +
theme(axis.title.x = element_text(colour = cols[3]) )
postDFreshape <- melt( mcmcChainDF, id.vars = "ITER", measure.vars = c("theta.1.", "theta.2.", "theta.3.", "theta.4.", "theta.5.", "theta.6.", "theta.7.", "theta.8.", "mu"))
plot = ggplot(postDFreshape,
aes(x = variable, y = value )) +
geom_boxplot( fill = c(rep(cols[3], deptsUniqCount),
cols[1]),
color = "darkgrey") +
ggtitle("Posterior Distributions") +
ylab( "posterior" ) +
xlab( "theta" ) +
scale_x_discrete( labels = c("BM","CH", "CS", "CV", "EE", "IN", "MC", "MS", "mu" )) +
theme(axis.title.x = element_text(colour = cols[3]) )
postDFreshape <- melt( mcmcChainDF, id.vars = "ITER", measure.vars = c("theta.1.", "theta.2.", "theta.3.", "theta.4.", "theta.5.", "theta.6.", "theta.7.", "theta.8.", "mu"))
plot = ggplot(postDFreshape,
aes(x = variable, y = value )) +
geom_boxplot( fill = c(rep(cols[3], deptsUniqCount),
cols[1]),
color = "darkgrey") +
ggtitle("Posterior Distributions") +
ylab( "posterior" ) +
xlab( "theta" ) +
scale_x_discrete( labels = c("BM","CH", "CS", "CV", "EE", "IN", "MC", "MS", "mu" )) +
theme(axis.title.x = element_text(colour = cols[3]) )
plot
postDFreshape <- melt( mcmcChainDF, id.vars = "ITER", measure.vars = c("theta.1.", "theta.2.", "theta.3.", "theta.4.", "theta.5.", "theta.6.", "theta.7.", "theta.8.", "mu"))
plot = ggplot(postDFreshape,
aes(x = variable, y = value )) +
geom_boxplot( fill = c(rep(cols[3], deptsUniqCount),
cols[1]),
color = "darkgrey") +
ggtitle("Posterior Distributions") +
ylab( "posterior" ) +
xlab( "theta" ) +
scale_x_discrete( labels = c("BM","CH", "CS", "CV", "EE", "IN", "MC", "MS", "mu" )) +
#theme(axis.title.x = element_text(colour = cols[3]) )
plot
postDFreshape <- melt( mcmcChainDF, id.vars = "ITER", measure.vars = c("theta.1.", "theta.2.", "theta.3.", "theta.4.", "theta.5.", "theta.6.", "theta.7.", "theta.8.", "mu"))
plot = ggplot(postDFreshape,
aes(x = variable, y = value )) +
geom_boxplot( fill = c(rep(cols[3], deptsUniqCount),
cols[1]),
color = "darkgrey") +
ggtitle("Posterior Distributions") +
ylab( "posterior" ) +
xlab( "theta" ) +
scale_x_discrete( labels = c("BM","CH", "CS", "CV", "EE", "IN", "MC", "MS", "mu" )) +
#theme(axis.title.x = element_text(colour = cols[3]) )
)
postDFreshape <- melt( mcmcChainDF, id.vars = "ITER", measure.vars = c("theta.1.", "theta.2.", "theta.3.", "theta.4.", "theta.5.", "theta.6.", "theta.7.", "theta.8.", "mu"))
plot = ggplot(postDFreshape,
aes(x = variable, y = value )) +
geom_boxplot( fill = c(rep(cols[3], deptsUniqCount),
cols[1]),
color = "darkgrey") +
ggtitle("Posterior Distributions") +
ylab( "posterior" ) +
xlab( "theta" ) +
scale_x_discrete( labels = c("BM","CH", "CS", "CV", "EE", "IN", "MC", "MS", "mu" ))
plot
postDFreshape <- melt( mcmcChainDF, id.vars = "ITER", measure.vars = c("theta.1.", "theta.2.", "theta.3.", "theta.4.", "theta.5.", "theta.6.", "theta.7.", "theta.8.", "mu"))
plot = ggplot(postDFreshape,
aes(x = variable, y = value )) +
geom_boxplot( fill = c(rep(cols[3], deptsUniqCount),
cols[1]),
color = "darkgrey") +
ggtitle("Posterior Distributions of Theta and Mu Parameters") +
ylab( "posterior" ) +
xlab( "theta" ) +
scale_x_discrete( labels = c("BM","CH", "CS", "CV", "EE", "IN", "MC", "MS", "mu" ))
plot
#use prec_pop and prec_theta to calculate:
#sigma^2 - variance between samples
#tau^2 - variance within a sample:
mcmcChainDF$sigma2 <- 1/mcmcChainDF$prec_pop
mcmcChainDF$tau2 <- 1/mcmcChainDF$prec_theta
mcmcChainDF$propVar <- mcmcChainDF$sigma2 /
(mcmcChainDF$sigma2 +
mcmcChainDF$tau2)
par(ask = F)
ggplot( mcmcChainDF, aes( x = sigma2 )) +
geom_density( color = "red") +
geom_histogram( aes(y = ..density.. ),
alpha = .3)
mean( mcmcChainDF$sigma2 )
sd( mcmcChainDF$sigma2 )
par(ask = F)
ggplot( mcmcChainDF, aes( x = tau2 )) +
geom_density( color = "red") +
geom_histogram( aes(y = ..density.. ),
alpha = .3)
mean( mcmcChainDF$tau2 )
sd( mcmcChainDF$tau2 )
par(ask = F)
ggplot( mcmcChainDF, aes( x = propVar )) +
geom_density( color = "red") +
geom_histogram( aes(y = ..density.. ),
alpha = .3)
mean( mcmcChainDF$propVar )
sd( mcmcChainDF$propVar )
print(propVar)
#use prec_pop and prec_theta to calculate:
#sigma^2 - variance between samples
#tau^2 - variance within a sample:
mcmcChainDF$sigma2 <- 1/mcmcChainDF$prec_pop
mcmcChainDF$tau2 <- 1/mcmcChainDF$prec_theta
mcmcChainDF$propVar <- mcmcChainDF$sigma2 /
(mcmcChainDF$sigma2 +
mcmcChainDF$tau2)
print(propVar)
print(mcmcChainDF$propVar)
#use prec_pop and prec_theta to calculate:
#sigma^2 - variance between samples
#tau^2 - variance within a sample:
mcmcChainDF$sigma2 <- 1/mcmcChainDF$prec_pop
mcmcChainDF$tau2 <- 1/mcmcChainDF$prec_theta
mcmcChainDF$propVar <- mcmcChainDF$sigma2 /
(mcmcChainDF$sigma2 +
mcmcChainDF$tau2)
ggplot( mcmcChainDF, aes( x = sigma2 )) +
geom_density( color = "red") +
geom_histogram( aes(y = ..density.. ),
alpha = .3)
par(ask = F)
ggplot( mcmcChainDF, aes( x = sigma2 )) +
geom_density( color = "red") +
geom_histogram( aes(y = ..density.. ),
alpha = .3)
mean( mcmcChainDF$sigma2 )
sd( mcmcChainDF$sigma2 )
par(ask = F)
ggplot( mcmcChainDF, aes( x = tau2 )) +
geom_density( color = "red") +
geom_histogram( aes(y = ..density.. ),
alpha = .3)
mean( mcmcChainDF$tau2 )
sd( mcmcChainDF$tau2 )
par(ask = F)
ggplot( mcmcChainDF, aes( x = propVar )) +
geom_density( color = "red") +
geom_histogram( aes(y = ..density.. ),
alpha = .3)
mean( mcmcChainDF$propVar )
sd( mcmcChainDF$propVar )
mean( mcmcChainDF$propVar )
sd( mcmcChainDF$propVar)
#use prec_pop and prec_theta to calculate:
#sigma^2 - variance between samples
#tau^2 - variance within a sample:
mcmcChainDF$sigma2 <- 1/mcmcChainDF$prec_pop
mcmcChainDF$tau2 <- 1/mcmcChainDF$prec_theta
mcmcChainDF$propVar <- mcmcChainDF$tau2 /
(mcmcChainDF$sigma2 +
mcmcChainDF$tau2)
par(ask = F)
ggplot( mcmcChainDF, aes( x = sigma2 )) +
geom_density( color = "red") +
geom_histogram( aes(y = ..density.. ),
alpha = .3)
mean( mcmcChainDF$sigma2 )
sd( mcmcChainDF$sigma2 )
par(ask = F)
ggplot( mcmcChainDF, aes( x = tau2 )) +
geom_density( color = "red") +
geom_histogram( aes(y = ..density.. ),
alpha = .3)
mean( mcmcChainDF$tau2 )
sd( mcmcChainDF$tau2 )
par(ask = F)
ggplot( mcmcChainDF, aes( x = propVar )) +
geom_density( color = "red") +
geom_histogram( aes(y = ..density.. ),
alpha = .3)
mean( mcmcChainDF$propVar)
sd( mcmcChainDF$propVar)
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(ggplot2)
library(scales)
library(reshape2)
mcmcChainDF$sigma2 <- 1/mcmcChainDF$precBTW
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(ggplot2)
library(scales)
library(reshape2)
salaries <- read.table("C:/Users/pmchu/Documents/Stat_3303/salaries.txt",header=T)
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(ggplot2)
library(grid)
library(gridExtra)
library(reshape2)
library(scales)
salaries <- read.table("salaries.txt",header=T)
#get salaries column
sal <- salaries$Salary
#n is total number entries
n <- length(sal)
#get unique number of departments. should be 8
depts <- as.factor(salaries$Dept)
deptsUniqCount <- length(unique(depts))
#convert to numeric and extract counts of each dept
deptsNum <- as.numeric(depts)
deptsCounts <- as.vector(table(deptsNum))
#create empty matrix to hold our data. this is in a format such that each col corresponds to a dept. Note: due to varying
#salary amounts for each dept, not all data will be filled in. Regardless, this makes it easier for jags to process properly
sal.Matrix <- matrix(c(NA), ncol=deptsUniqCount,nrow=max(deptsCounts))
for (i in 1:deptsUniqCount){
temp <- sal[which(deptsNum == i)]
col <- c(temp, rep(NA, nrow(sal.Matrix)-length(temp)))
sal.Matrix[,i] <- col
}
# create a data list
dataList = list('sal.Matrix' = sal.Matrix,  'deptsCounts' = deptsCounts, 'deptsUniqCount' =deptsUniqCount)
# list of parameters to be monitored
parameters <- c("theta", "mu", "prec.within", "prec.btw")
# set initial values
initsValues <- list("theta" = rep(80,deptsUniqCount), "mu"=80, "prec.within" = 1/100, "prec.btw"=1/100)
# number of iteration for "tuning"
adaptSteps <- 5000
# number of iterations for "burn-in"
burnInSteps <- 5000
# number of chains to run
nChains <- 2
# total number of iterations to save
numSavedSteps <- 5000
# "thinning" (1 = keep every interation)
thinSteps <- 1
# iterations per chain
ITER <- ceiling((numSavedSteps * thinSteps )/ nChains)
# -------------
# Run JAGS
# -------------
# create, initialize, and adapt the model
jagsModel <- jags.model("salaries_model.txt", data = dataList, inits = initsValues, n.chains = nChains, n.adapt = adaptSteps)
# burn-in the algorithm
update(jagsModel, n.iter = burnInSteps)
# run algorithm to get interations for inference
codaSamples <- coda.samples(jagsModel, variable.names = parameters, n.iter = ITER, thin = thinSteps)
initsValues
initsValues
print(c(adaptSteps, burnInSteps, ITER))
# -------------
# Look at posterior samples
# -------------
# make a dataframe with the posterior samples
mcmcChainDF <- data.frame(as.matrix(codaSamples, iters = T, chains = T))
# create a vector with the variable names
varNames <- names(mcmcChainDF)[3:(dim(mcmcChainDF)[2])]
# number of variables
nVars <- length(varNames)
mcmcChainDF$CHAIN <- as.factor(mcmcChainDF$CHAIN)
# construct trace plots
par(ask = T)
for( i in 1:nVars ){
print(ggplot(mcmcChainDF, aes( x = ITER, y = mcmcChainDF[ ,varNames[i]])) +
geom_line(aes(color = CHAIN)) +
labs(y = varNames[i]))
flush.console()
}
postDFreshape <- melt( mcmcChainDF, id.vars = "ITER", measure.vars = c("theta.1.", "theta.2.", "theta.3.", "theta.4.", "theta.5.", "theta.6.", "theta.7.", "theta.8.", "mu"))
plot = ggplot(postDFreshape,
aes(x = variable, y = value )) +
geom_boxplot( fill = c(rep(cols[3], deptsUniqCount),
cols[1]),
color = "darkgrey") +
ggtitle("Posterior Distributions of Theta and Mu Parameters") +
ylab( "posterior" ) +
xlab( "theta" ) +
scale_x_discrete( labels = c("BM","CH", "CS", "CV", "EE", "IN", "MC", "MS", "mu" ))
plot
#use prec.within and prec.btw to calculate:
#sigma^2 - variance within samples
#tau^2 - variance between a sample:
mcmcChainDF$sigma2 <- 1/mcmcChainDF$prec.btw
mcmcChainDF$prec.btw
mcmcChainDF
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(ggplot2)
library(grid)
library(gridExtra)
library(reshape2)
library(scales)
salaries <- read.table("salaries.txt",header=T)
#get salaries column
sal <- salaries$Salary
#n is total number entries
n <- length(sal)
#get unique number of departments. should be 8
depts <- as.factor(salaries$Dept)
deptsUniqCount <- length(unique(depts))
#convert to numeric and extract counts of each dept
deptsNum <- as.numeric(depts)
deptsCounts <- as.vector(table(deptsNum))
#create empty matrix to hold our data. this is in a format such that each col corresponds to a dept. Note: due to varying
#salary amounts for each dept, not all data will be filled in. Regardless, this makes it easier for jags to process properly
sal.Matrix <- matrix(c(NA), ncol=deptsUniqCount,nrow=max(deptsCounts))
for (i in 1:deptsUniqCount){
temp <- sal[which(deptsNum == i)]
col <- c(temp, rep(NA, nrow(sal.Matrix)-length(temp)))
sal.Matrix[,i] <- col
}
# create a data list
dataList = list('sal.Matrix' = sal.Matrix,  'deptsCounts' = deptsCounts, 'deptsUniqCount' =deptsUniqCount)
# list of parameters to be monitored
parameters <- c("theta", "mu", "prec.within", "prec.btw")
# set initial values
initsValues <- list("theta" = rep(80,deptsUniqCount), "mu"=80, "prec.within" = 1/100, "prec.btw"=1/100)
# number of iteration for "tuning"
adaptSteps <- 5000
# number of iterations for "burn-in"
burnInSteps <- 5000
# number of chains to run
nChains <- 2
# total number of iterations to save
numSavedSteps <- 5000
# "thinning" (1 = keep every interation)
thinSteps <- 1
# iterations per chain
ITER <- ceiling((numSavedSteps * thinSteps )/ nChains)
# -------------
# Run JAGS
# -------------
# create, initialize, and adapt the model
jagsModel <- jags.model("salaries_model.txt", data = dataList, inits = initsValues, n.chains = nChains, n.adapt = adaptSteps)
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(ggplot2)
library(grid)
library(gridExtra)
library(reshape2)
library(scales)
salaries <- read.table("salaries.txt",header=T)
#get salaries column
sal <- salaries$Salary
#n is total number entries
n <- length(sal)
#get unique number of departments. should be 8
depts <- as.factor(salaries$Dept)
deptsUniqCount <- length(unique(depts))
#convert to numeric and extract counts of each dept
deptsNum <- as.numeric(depts)
deptsCounts <- as.vector(table(deptsNum))
#create empty matrix to hold our data. this is in a format such that each col corresponds to a dept. Note: due to varying
#salary amounts for each dept, not all data will be filled in. Regardless, this makes it easier for jags to process properly
sal.Matrix <- matrix(c(NA), ncol=deptsUniqCount,nrow=max(deptsCounts))
for (i in 1:deptsUniqCount){
temp <- sal[which(deptsNum == i)]
col <- c(temp, rep(NA, nrow(sal.Matrix)-length(temp)))
sal.Matrix[,i] <- col
}
# create a data list
dataList = list('sal.Matrix' = sal.Matrix,  'deptsCounts' = deptsCounts, 'deptsUniqCount' =deptsUniqCount)
# list of parameters to be monitored
parameters <- c("theta", "mu", "prec.within", "prec.btw")
# set initial values
initsValues <- list("theta" = rep(80,deptsUniqCount), "mu"=80, "prec.within" = 1/100, "prec.btw"=1/100)
# number of iteration for "tuning"
adaptSteps <- 5000
# number of iterations for "burn-in"
burnInSteps <- 5000
# number of chains to run
nChains <- 2
# total number of iterations to save
numSavedSteps <- 5000
# "thinning" (1 = keep every interation)
thinSteps <- 1
# iterations per chain
ITER <- ceiling((numSavedSteps * thinSteps )/ nChains)
# -------------
# Run JAGS
# -------------
# create, initialize, and adapt the model
jagsModel <- jags.model("salaries_model.txt", data = dataList, inits = initsValues, n.chains = nChains, n.adapt = adaptSteps)
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(ggplot2)
library(grid)
library(gridExtra)
library(reshape2)
library(scales)
salaries <- read.table("salaries.txt",header=T)
#get salaries column
sal <- salaries$Salary
#n is total number entries
n <- length(sal)
#get unique number of departments. should be 8
depts <- as.factor(salaries$Dept)
deptsUniqCount <- length(unique(depts))
#convert to numeric and extract counts of each dept
deptsNum <- as.numeric(depts)
deptsCounts <- as.vector(table(deptsNum))
#create empty matrix to hold our data. this is in a format such that each col corresponds to a dept. Note: due to varying
#salary amounts for each dept, not all data will be filled in. Regardless, this makes it easier for jags to process properly
sal.Matrix <- matrix(c(NA), ncol=deptsUniqCount,nrow=max(deptsCounts))
for (i in 1:deptsUniqCount){
temp <- sal[which(deptsNum == i)]
col <- c(temp, rep(NA, nrow(sal.Matrix)-length(temp)))
sal.Matrix[,i] <- col
}
# create a data list
dataList = list('sal.Matrix' = sal.Matrix,  'deptsCounts' = deptsCounts, 'deptsUniqCount' =deptsUniqCount)
# list of parameters to be monitored
parameters <- c("theta", "mu", "prec.within", "prec.btw")
# set initial values
initsValues <- list("theta" = rep(80,deptsUniqCount), "mu"=80, "prec.within" = 1/100, "prec.btw"=1/100)
# number of iteration for "tuning"
adaptSteps <- 5000
# number of iterations for "burn-in"
burnInSteps <- 5000
# number of chains to run
nChains <- 2
# total number of iterations to save
numSavedSteps <- 5000
# "thinning" (1 = keep every interation)
thinSteps <- 1
# iterations per chain
ITER <- ceiling((numSavedSteps * thinSteps )/ nChains)
# -------------
# Run JAGS
# -------------
# create, initialize, and adapt the model
jagsModel <- jags.model("salaries_model.txt", data = dataList, inits = initsValues, n.chains = nChains, n.adapt = adaptSteps)
# burn-in the algorithm
update(jagsModel, n.iter = burnInSteps)
# run algorithm to get interations for inference
codaSamples <- coda.samples(jagsModel, variable.names = parameters, n.iter = ITER, thin = thinSteps)
initsValues
initsValues
print(c(adaptSteps, burnInSteps, ITER))
# -------------
# Look at posterior samples
# -------------
# make a dataframe with the posterior samples
mcmcChainDF <- data.frame(as.matrix(codaSamples, iters = T, chains = T))
# create a vector with the variable names
varNames <- names(mcmcChainDF)[3:(dim(mcmcChainDF)[2])]
# number of variables
nVars <- length(varNames)
mcmcChainDF$CHAIN <- as.factor(mcmcChainDF$CHAIN)
# construct trace plots
par(ask = T)
for( i in 1:nVars ){
print(ggplot(mcmcChainDF, aes( x = ITER, y = mcmcChainDF[ ,varNames[i]])) +
geom_line(aes(color = CHAIN)) +
labs(y = varNames[i]))
flush.console()
}
postDFreshape <- melt( mcmcChainDF, id.vars = "ITER", measure.vars = c("theta.1.", "theta.2.", "theta.3.", "theta.4.", "theta.5.", "theta.6.", "theta.7.", "theta.8.", "mu"))
plot = ggplot(postDFreshape,
aes(x = variable, y = value )) +
geom_boxplot( fill = c(rep(cols[3], deptsUniqCount),
cols[1]),
color = "darkgrey") +
ggtitle("Posterior Distributions of Theta and Mu Parameters") +
ylab( "posterior" ) +
xlab( "theta" ) +
scale_x_discrete( labels = c("BM","CH", "CS", "CV", "EE", "IN", "MC", "MS", "mu" ))
plot
#use prec.within and prec.btw to calculate:
#sigma^2 - variance within samples
#tau^2 - variance between a sample:
mcmcChainDF$sigma2 <- 1/mcmcChainDF$prec.btw
mcmcChainDF$tau2 <- 1/mcmcChainDF$prec.within
mcmcChainDF$propVar <- mcmcChainDF$sigma2 /
(mcmcChainDF$sigma2 +
mcmcChainDF$tau2)
par(ask = F)
ggplot( mcmcChainDF, aes( x = sigma2 )) +
geom_density( color = "red") +
geom_histogram( aes(y = ..density.. ),
alpha = .3)
mean( mcmcChainDF$sigma2 )
sd( mcmcChainDF$sigma2 )
par(ask = F)
ggplot( mcmcChainDF, aes( x = tau2 )) +
geom_density( color = "red") +
geom_histogram( aes(y = ..density.. ),
alpha = .3)
mean( mcmcChainDF$tau2 )
sd( mcmcChainDF$tau2 )
par(ask = F)
ggplot( mcmcChainDF, aes( x = propVar )) +
geom_density( color = "red") +
geom_histogram( aes(y = ..density.. ),
alpha = .3)
mean( mcmcChainDF$propVar)
sd( mcmcChainDF$propVar)
bm.post <- mcmcChainDF$theta.1.
num_bm = length(bm.post)
probability <- length(which(bm.post > 140))/num_bm
print(probability)
